<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //1、堆内存的释放:
    //->定义一个引用数据类型的值就会产生一个堆内存(引用数据类型开辟的那个内存空间)
    //->每个浏览器对于内存的释放机制是不一样的,但是都是判断当前的内存有没有被占用,如果被占用了,就不能释放,没有被占用就会被释放
    //    var obj = {};//->obj=xxxfff000
    //    obj = null;
    //->我们创建的引用数据类型值(堆内存),如果后期没有用的话,我们不要忘记手动给其占用的变量赋值为null,这样的话,当前的堆内存就不会被占用了,浏览器会在空闲的时候把这个堆内存释放掉

    //2、栈内存释放
    //->window全局作用域:它只有在页面关闭的时候才会被释放掉(可以理解为不销毁的栈内存)
    //->私有的作用域:

    //1)立即销毁的私有作用域：
    //->一般情况下,函数执行完成后,当前形成的这个私有的作用域都会被立即销毁了(因为函数执行完成后就没啥用了)

    //2)不销毁的私有作用域:
    //->但是有些时候,函数执行形成的那个私有的作用域(A),它的堆内存里面有一部分内容被A以外的变量给占用了,堆内存不能删那么此时的A就不能销毁了
    //->形式：
    // 一个函数执行,形成一个私有的作用域A,A中返回了一个引用数据类型的值,并且返回的值(地址)被A以外的变量(eg:f)接收了,导致了A不能销毁

    //3)不立即销毁的私有作用域:

    function fn() {
        var i = 2; //3 4
        return function (n) {
            console.log(n + (++i));
        }
    }
    console.log(fn(10));
    var f = fn();
    f(10);//13
    f(20);//24
    fn()(10);//->先让fn这个函数执行,把返回的小函数紧接着在执行,并且传递一个值10 //13
    fn()(20);//23



//    function fn(i) {
//        //参数相等于在函数体内声明了一个变量
//        var i = 2;
//        return function (n) {
//            console.log(n + (++i));
//        }
//    }
//    fn(45)(10);//13

    function fn(i) {
        return function x(n) {
            console.log(n + (++i));
        }
    }

    fn(45)(10);//56

</script>
</body>
</html>